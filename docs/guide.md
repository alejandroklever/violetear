# User Guide

This is a step-by-step guide to using `violetear`. In this guide, we will build a sample website. You can see the sample website alive [here](guide.html) and the final source code [here](https://github.com/apiad/violetear/tree/main/docs/guide.html).

Before starting, make sure to have `violetear` installed:

```bash
pip install violetear # (1)
```

1. This will install the latest version with `pip`.
   You can install a custom version with `pip install violetear==<version>`.


## Basic setup

We'll start by creating a blank HTML file with a basic markup:

```html title="guide.html"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Example Web Page - violetear</title>
</head>
<body>

</body>
</html>
```

Go ahead and paste that into a new file [`guide.html`](guide.html) and hit the save button!

### Stylesheets

Next, we'll create a new file [`styles.py`](styles.py) where we will define all our styles. Start by importing the `StyleSheet` class and creating an instance. We'll pass `normalize=True` to ask `violetear` to generate an initial set of CSS rules that normalize styles across modern browsers (taken from [modern-normalize](https://github.com/sindresorhus/modern-normalize)).

```python title="styles.py"
from violetear import StyleSheet

sheet = StyleSheet(normalize=True)

# ... (1)

sheet.render("styles.css")
```

1. Code for each of the styles goes in here.

Run the file `styles.py` and verify that it creates a [`styles.css`](styles.css) file. If you open it you should see a short preamble followed by the normalization rules:

```css title="styles.css"
/* Made with violetear */
/* Generating all 0 styles */
/* Autogenerated on 2022-08-17 22:44:26.345293 */

/*! modern-normalize v1.1.0 ... */
/* (1) */
```

1. The rest of the CSS rules will follow.

Now go ahead and add the style link to your HTML:

```html title="guide.html" hl_lines="4"
...
<head>
   <!-- (1) -->
   <link rel="stylesheet" href="styles.css">
</head>
...
```

1. The rest of the header we already saw.

Now we're ready to start adding some markup and styles.

## Simple styling

Let's start by adding some content: a title, a subtitle, and some paragraphs (in latin!):

```html title="guide.html"
...
<body>
    <h1>An important lesson</h1>
    <h2>Given by some important guy...</h2>
    <p>
        Sint nesciunt architecto ipsam quia.
        Deleniti explicabo fuga velit.
        Iste occaecati sunt veniam veniam quas ratione nihil.
        Velit nam eum in a nam ratione.
    </p>
    <p>
        Aut quo culpa alias voluptates voluptatem debitis et aperiam.
        Et illo qui quae.
        Alias aut repellat quidem et cum aut.
        Repudiandae doloribus vero quibusdam veniam nam in.
    </p>
    <p>
        Voluptas ut rerum aut harum libero.
        Qui sint et sapiente non fugiat soluta commodi.
        Deserunt ipsum quo autem.
        Inventore in et dolorem.
        Enim nobis in quia quisquam dolorem similique eos.
        Repellat eum consequatur sunt velit eum earum hic tenetur.
    </p>
</body>
```

If you open the `guide.html` file right you'll see it's just some unstyled text. So let's add some color.

### Geometry

First, let's make those borders narrower by constraining the width of the `body` tag:

```python title="styles.py"
# ... after sheet = StyleSheet(...)

sheet.select('body').width(0.8, max=768).margin("auto", top=50)

# ... before sheet.render(...)
```

Go ahead and run `styles.py` before reloading the page and you'll see that now we have some nice responsive margins with a maximum width. Try resizing the browser window to see the effect.

Let's break down that one-liner to see what's happening in slow-motion:

- `sheet.select(...)` defines a new blank style. The `select` method receives a CSS selector, in this case, it's the simplest possible selector (`"body"`) but you can use id (e.g., `"#title"`), classes (e.g., `".btn"`) and states (e.g., `":hover"`). The method returns and instance of the `Style` class which lets you chain methods to add the actual CSS rules.
- `.width(...)` defines the rules for the width of the element. In this case we're setting the width to 80% of the parent width, but with a maximum of 768 pixels. As a general idea, anytime you have a set of related attributes in CSS (e.g., `width`, `min-width`, and `max-width`), you'll have a single method in `violetear` that let's you set several of those related attributes in a single call.
- `.margin(...)` defines the overall margin (`auto`) plus a specific value for the top margin of 50 pixels. All methods in `violetear` that take numerical units can receive an instance of the `Unit` class, which can represent pixels, percentages, em, rem, points, etc. For simplicity, plain ints and floats are converted to a sensible unit (e.g., floats are treated as percentages in the case of box geometry, but as rem in the case of font sizes). Later on we'll see how to use `Unit` explicitely.

!!! question "Why the big deal?"

    It may seem that so far there's nothing to be gained from using `violetear` on top of pure CSS.
    You have to basically write the same rules with the same values.
    The big deal is (so far) that by using a programming language you already know, you can leverage all the tooling you already have to make your coding more productive.

    I promise in the next few sections you'll see way more powerful features but, for now, even if you only use `violetear` to write all your CSS explicitly, there's something important to be gained.
    Since related styles are grouped in a single method in `violetear`, and all methods are fully typed and documented, you have automatic CSS intellisense and linting.

    And yes, maybe you can have that for pure CSS too with the right extensions, but for only for individual rules.
    To understand how different rules play together to define a single styling concept (like borders), you have to read the documentation of all the `border-*` rules.

### Base style

As a fine tweak, let's soften the colors a little bit. For this purpose, we can define custom styles for the tags`<h1>`. `<h2>` and `<p>`, but that would be kinda repetitive. So instead, we'll define a *base style* in the `StyleSheet` constructor that all styles will inherit. We will need to import `Style` and `Color` to create a base style, and rewrite our constructor call:

```python  title="styles.py"
from violetear import StyleSheet, Style, Color
from violetear.color import gray

base_style = Style().color(gray(0.3))
sheet = StyleSheet(normalize=True, base=base_style)

# ... (1)
```

1. Here are all the rules.

`gray(...)` defines a new color using a gray tone with a given luminosity, such that `0` is black and `1` is white. Similarly, you'll find `red`, `green` and `blue` methods to create colors for every luminosity value. More about colors follows [further down](#playing-with-colors) in this guide.

## Creating styles programmatically

Finally, let's change the all the fonts to some custom values. For this purpose we will first create a sequence of sizes using `Unit.scale`, and then programatically create the three styles with a simple `for` loop.

```python title="example.py" hl_lines="1 8 9"
from violetear import StyleSheet, Style, Color, Unit, rem

base_style = Style().color(Color.gray(0.3))
sheet = StyleSheet(normalize=True, base=base_style)

sheet.select("body").width(0.8, max=768).margin("auto", top=50)

for i, size in enumerate(Unit.scale(rem, 1, 2.25, 3)):
    sheet.select(f".size-{i}").font(size, weight=300)

sheet.render("styles.css")
```

Now take a look at the `styles.css` file and you'll notice the new styles at the end:

```css title="styles.css"
/* (1) */

.size-0 {
    color: rgba(76,76,76,1);
    font-size: 1rem;
    font-weight: 300;
}

.size-1 {
    color: rgba(76,76,76,1);
    font-size: 1.625rem;
    font-weight: 300;
}

.size-2 {
    color: rgba(76,76,76,1);
    font-size: 2.25rem;
    font-weight: 300;
}
```

1. Previous rules are up here.

As you can see, we have quickly defined three very similar styles with different font sizes and a single font weight. Let's break it down:

- `Unit.scale` creates a sequence of equally spaced values in a range. Here we called it with `1` and `2.25` as range, and `3` steps. The first parameter uses the function `rem` to define what specific unit is used. You can check in `violetear.units` to see which other units are available.
- The `enumerate(...)`  functions wraps the `Unit.scale` iterable and returns tuples of `i, size`.
- In the body of the `for` loop we create one style for each size, selecting a class `.size-{i}`, hence we'll end with `.size-0`, `.size-1` and `.size-2`.
- Each style also inherited the `base_style` we defined previously.

To apply these styles, we'll need to modify our `guide.html` source to put the right classes in place:

```html title="guide.html" hl_lines="3 4 5 8 11"
<!-- (1) -->
<body>
    <h1 class="size-2">An important lesson</h1>
    <h2 class="size-1">Given by some important guy...</h2>
    <p class="size-0">
        <!-- (2) -->
    </p>
    <p class="size-0">
        <!-- (3) -->
    </p>
    <p class="size-0">
        <!-- (4) -->
    </p>
</body>
```

1. Rest of the HTML goes here.
2. Paragraph content is hidden for simplicity.
3. Paragraph content is hidden for simplicity.
4. Paragraph content is hidden for simplicity.

!!! tip "More than just CSS"

    Now you can begin to appreciate the power of using something like `violetear` instead of plain CSS, or even CSS supersets like Sass or Less. Combining a few parameters and loops you can imagine how to create complex design systems with dozens of font sizes, styles, colors, etc.


## Playing with colors

Now let's take a taste of `violetear`'s power to create expressive designs with minimum effort.
We will create a color palette and use it to style a row of `div`s.

Firs the markup, add the following at the end of your `body` tag:

```html title="guide.html"
<!-- (1) -->
<body>
    <!-- (2) -->
    <div id="color-palette">
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>
</body>
```

1. The rest of the HTML is hidden for simplicity.
2. The rest of the HTML is hidden for simplicity.

Back to our `styles.py` file, let's create a color palette. The method `Color.palette` works similarly to `Unit.scale`, but with colors. It accepts start and end colors (here, `red(0.3)` and `blue(0.7)`) and a number of steps, and it outputs a sequence of `Color` objects that equally distributed in color space (you can pass a `space` parameter, `"hsl"`, `"hsv"` or `"rgb"`):

```python title="styles.py" hl_lines="3"
# ... (1)

palette = Color.palette(Color.red(0.3), Color.blue(0.7), 10)
root = sheet.select("#color-palette").flexbox()

for i, color in enumerate(palette):
    root.children('div', nth=i+1).width(1.0).height(10).margin(0.1).background(color)

sheet.render("styles.css")
```

1. The first part of the script is hidden for simplicity.

Next, we select the container `div` with id `color-palette` and apply a simple *flexbox* style. This causes that all children `div`s are automatically layout in row. More on the flexbox and other layout options [later on in this guide](#layout-options).

```python title="styles.py" hl_lines="4"
# ... (1)

palette = Color.palette(Color.red(0.3), Color.blue(0.7), 10)
root = sheet.select("#color-palette").flexbox()

for i, color in enumerate(palette):
    root.children('div', nth=i+1).width(1.0).height(10).margin(0.1).background(color)

sheet.render("styles.css")
```

1. The first part of the script is hidden for simplicity.

And finally, we iteratively style each of the children `div`s with `.children('div', nth=i+1)`.
This method creates and returns a blank style for the selected child(ren) to which you can chain additional styling methods.
Since these `div`s are already layout as flex items, we just need to give them an appropiate width (100% in this case) and height (25 pixels), a minimum margin (`0.1 rem`) and apply one of the colors of the scale.

```python title="styles.py" hl_lines="6 7"
# ... (1)

palette = Color.palette(Color.red(0.3), Color.blue(0.7), 10)
root = sheet.select("#color-palette").flexbox()

for i, color in enumerate(palette):
    root.children('div', nth=i+1).width(1.0).height(10).margin(0.1).background(color).rounded()

sheet.render("styles.css")
```

1. The first part of the script is hidden for simplicity.

!!! tip "Choose your own style"
    As you may have noticed, `violetear` is completely unopinionated. Do you want to style an existing HTML? Do you want to create a complete semantic design system like Bootstrap? Do you prefer a simple utility system like Tailwind? Since `violetear` is just a thin layer on top of CSS, it doesn't force you into any specific design philosophy. You can even mix and match different styles.

    This is yet another example of `violetear`'s unopinionated philosophy. Here we are styling children by the `:nth-child()` selector instead of having to explicitely define classes in the HTML.
    Whether you prefer explicit or implicit is up to your design philosophy, `violetear` will help you either way.

## Layout options

### Flexible layouts

The previous section showed you a glimpse of the `.flexbox()` layout method. Let's explore it's options. Start by adding a bunch of `div`s to play with:

```html title="guide.html"
<!-- (1) -->
<body>
    <!-- (2) -->
    <div id="gallery">
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
    </div>
</body>
```

1. The rest of the HTML is hidden for simplicity.
2. The rest of the HTML is hidden for simplicity.

First we style the `div#gallery` with a flexbox style with item wraping. The `.flexbox()` method configures the flexbox container, allowing to set the direction, wrap, reverse, alignment and justification of items.

```python title="styles.py" hl_lines="3"
# ... (1)

gallery = sheet.select("#gallery").flexbox(wrap=True, justify="space-around")
gallery.children("div").flex(1).width(min=100, max=200).height(100).background(
    Color.gray(0.9)
).margin(0.1)

sheet.render("styles.css")
```

1. The first part of the script is hidden for simplicity.

Next we style the children, setting the minimum and maximum width to 100 and 200 pixels respectively, and a light gray color to make them easier to distinguish. The most important method is `.flex()` which configures the flex items. The first parameter is the grow factor. You can also configure the shrink factor and the initial basis.

```python title="styles.py" hl_lines="4 5 6"
# ... (1)

gallery = sheet.select("#gallery").flexbox(wrap=True, justify="space-around")
gallery.children("div").flex(1).width(min=100, max=200).height(100).background(
    Color.gray(0.9)
).margin(0.1)

sheet.render("styles.css")
```

1. The first part of the script is hidden for simplicity.

Try resizing the browser window to check the effect.

### Grid layouts

Now let's instead apply a grid layout. Start by selecting the same `#gallery` element and applying `.grid()`. This method configures the grid layout, and it is very expressive. You can set a fixed number of columns and/or rows with different sizes or fractions, configure the automatically created columns or rows, and you can use the `repeat` and `minmax` patterns from the CSS grid specification. However, in its simplest form, you can just pass a number and it will create a fixed set of `1fr` columns or rows.

```python title="styles.py" hl_lines="3"
# ... (1)

grid = sheet.select("#gallery").grid(columns=3)
grid.children("div").width(max=1.0)
grid.children("div", nth=7).place(columns=(1, 3))

sheet.render("styles.css")
```

1. The first part of the script is hidden for simplicity.

Next, we reset the children width to a maximum of `100%` to make them cover the whole columns.

```python title="styles.py" hl_lines="4"
# ... (1)

grid = sheet.select("#gallery").grid(columns=3)
grid.children("div").width(max=1.0)
grid.children("div", nth=7).place(columns=(1, 3))

sheet.render("styles.css")
```

1. The first part of the script is hidden for simplicity.

And finally, we'll make the last child take up all three columns (contrary to the CSS specification, the end value is inclusive, which I find much more intuitive).

```python title="styles.py" hl_lines="5"
# ... (1)

grid = sheet.select("#gallery").grid(columns=3)
grid.children("div").width(max=1.0)
grid.children("div", nth=7).place(columns=(1, 3))

sheet.render("styles.css")
```

1. The first part of the script is hidden for simplicity.
## Media queries

Even with flexible and responsive layouts, sometimes you just need to do things differently in different screens. This is when media queries come in handy.
To define styles conditioned on media queries, `violetear` provides a context manager API that allows configuring different media sets.

```python title="example.py" hl_lines="3"
# ... (1)

with sheet.media(max_width=600):
    sheet.select("body").width(1.0).padding(left=10, right=10)
    sheet.redefine(root).flexbox("column").children("div").width(max=200)

sheet.render("styles.css")
```

1. The first part of the script is hidden for simplicity.

When inside the context manager scope, `.select(...)` creates styles that are conditioned to a given media query.
Hence, you can override an existing style simply by using the same selector and applying only the style that changes.
In this case, we want the body to extend to the full width (minus some padding) when the screen is small enough.


```python title="example.py" hl_lines="4"
# ... (1)

with sheet.media(max_width=600):
    sheet.select("body").width(1.0).padding(left=10, right=10)
    sheet.redefine(root).flexbox("column").children("div").width(max=200)

sheet.render("styles.css")
```

1. The first part of the script is hidden for simplicity.

However, since writing the same selectors isn't very DRY, you can use the `.redefine()` method to copy the selector from an existing style. This way, if your markup changes, and thus the selectors, you only need to change them in one place, the first time you define them.

Here we change the palette flexbox direction to column-wise instead of row-wise, and immediately reset the children width. Try resizing the browser to less than 600 pixels wide to see the effect.

```python title="example.py" hl_lines="5"
# ... (1)

with sheet.media(max_width=600):
    sheet.select("body").width(1.0).padding(left=10, right=10)
    sheet.redefine(root).flexbox("column").children("div").width(max=200)

sheet.render("styles.css")
```

1. The first part of the script is hidden for simplicity.

After running the script, check out the `style.css` file to confirm that our media query is indeed defined as we expected:

```css title="styles.css"
/* (1) */

@media (max-width: 600px){
    body {
        color: rgba(76,76,76,1);
        width: 100.0%;
        padding-left: 10px;
        padding-right: 10px;
    }

    #color-palette {
        display: flex;
        flex-direction: column;
    }

    #color-palette>div {
        max-width: 200px;
    }

    #gallery {
        visibility: hidden;
    }

}
```

1. The rest of the CSS file is omited for simplicity.

!!! question "Mobile-first or Desktop-first?"

    When designing your layout, an important question is whether to go mobile- or desktop-first.
    In a mobile-first design, your main layout (without media queries) is optimized for a mobile screen,
    and then you add media queries at different break points of bigger screens (using increasingly bigger values for `min_width`).
    Alternatively, in a desktop-first design, your main layout is optimized for a normal screen and then you add media queries for smaller screens (with increasingly smaller values for `max_width`).

    Like in all previous design decisions, `violetear` will not force you to choose either approach. You're free to design mobile-first, desktop-first, or use any combination of media queries that you desire.

## Where to go from here

This covers all the basic concepts in `violetear`, but of course there is much more you can learn.

- You can [browse the examples](./examples) to see concrete, much more detailed use cases.
- You can [read the annotated API](./api) to see how everything works under the hood.

If you need any additional help, or find something that's not quite as you'd expect, don't hesitate to ask by [opening an issue](https://github.com/apiad/violetear/issues).